body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
}
canvas {
    width: 100%;
    height: 100%;
    display: block;
}
</style></head><body>
<canvas id="glCanvas"></canvas>
<script>
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2');

if (!gl) {
    console.error('WebGL 2 not supported');
    document.body.innerHTML = 'WebGL 2 is not supported in your browser.';
}

const vertexShaderSource = `#version 300 es
in vec4 aPosition;
void main() {
    gl_Position = aPosition;
}`;
  
const fragmentShaderSource = `#version 300 es
precision highp float;

uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

out vec4 fragColor;

const float PI = 3.14159265359;
const float MAX_DIST = 100.0;

const vec3 CANDY_PINK = vec3(0.95, 0.5, 0.7);
const vec3 CANDY_BLUE = vec3(0.4, 0.7, 0.9);
const vec3 CANDY_PURPLE = vec3(0.7, 0.4, 0.8);
const vec3 CANDY_WHITE = vec3(0.95, 0.95, 0.95);
const vec3 MILK_COLOR = vec3(0.98, 0.95, 0.9);

// Improved noise with glitch effect
float hash(float n) { 
    return fract(sin(n) * 43758.5453123 + sin(iTime * 0.1) * 10.0); 
}

vec3 glitchOffset(vec3 p) {
    float glitchTime = floor(iTime * 4.0) * 0.25;
    vec3 glitch = vec3(
        hash(p.x + glitchTime * 13.37),
        hash(p.y + glitchTime * 7.12),
        hash(p.z + glitchTime * 5.89)
    );
    return glitch * 0.1 * step(0.95, hash(glitchTime));
}

float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    
    float n = p.x + p.y * 157.0 + 113.0 * p.z;
    return mix(mix(
        mix(hash(n + 0.0), hash(n + 1.0), f.x),
        mix(hash(n + 157.0), hash(n + 158.0), f.x),
        f.y),
        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
            mix(hash(n + 270.0), hash(n + 271.0), f.x),
            f.y),
        f.z);
}

float fbm(vec3 p) {
    float f = 0.0;
    float amp = 0.5;
    for(int i = 0; i < 4; i++) {
        f += amp * noise(p + glitchOffset(p));
        p *= 2.0;
        amp *= 0.5;
    }
    return f;
}

// Deformed primitives
float sdSphere(vec3 p, float r) {
    // Add wobble and glitch deformation
    vec3 glitch = glitchOffset(p);
    float wobble = sin(iTime * 2.0 + p.y * 5.0) * 0.1;
    float deformation = sin(p.x * 10.0 + iTime) * cos(p.z * 8.0 + iTime) * 0.1;
    return length(p + glitch) - (r + wobble + deformation);
}

float sdBox(vec3 p, vec3 b) {
    // Add twist and glitch deformation
    float twist = iTime * 0.5;
    float c = cos(twist * p.y);
    float s = sin(twist * p.y);
    vec3 twisted = vec3(
        c * p.x - s * p.z,
        p.y,
        s * p.x + c * p.z
    );
    vec3 glitch = glitchOffset(p);
    vec3 q = abs(twisted + glitch) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float milkOcean(vec3 p) {
    vec3 glitch = glitchOffset(p);
    float waves = sin(p.x * 2.0 + iTime) * 0.2 + 
                 cos(p.z * 1.5 + iTime * 0.8) * 0.2;
    float ripples = fbm(vec3(p.xz * 3.0, iTime * 0.5)) * 0.15;
    
    // Add chaotic waves
    float chaos = sin(p.x * 4.0 + iTime * 2.0) * cos(p.z * 3.0 + iTime) * 0.1;
    
    return p.y + 2.0 + waves + ripples + chaos + glitch.y;
}

float floatingCandy(vec3 p) {
    vec3 q = p;
    // Add more chaotic movement
    q.y += sin(iTime + p.x * 2.0) * 0.5;
    q.x += cos(iTime * 0.7 + p.z * 1.5) * 0.4;
    q.z += sin(iTime * 0.5 + p.x * 1.2) * 0.3;
    
    // Add glitch displacement
    q += glitchOffset(q);
    
    float candy1 = sdBox(q - vec3(2.0, 1.0, 0.0), vec3(0.2));
    float candy2 = sdSphere(q - vec3(-1.5, 0.5, 1.0), 0.3);
    float candy3 = sdBox(q - vec3(0.0, 1.5, -1.0), vec3(0.15));
    
    // Add distortion
    float distortion = sin(iTime * 3.0 + p.y * 10.0) * 0.1;
    
    return min(min(candy1, candy2), candy3) + distortion;
}

float candyPlanet(vec3 p) {
    // Add rotation and deformation
    float angle = iTime * 0.5;
    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    p.xz = rot * p.xz;
    
    vec3 glitch = glitchOffset(p);
    float sphere = sdSphere(p + glitch, 1.0);
    
    // Enhanced candy swirls with glitch effect
    float swirls = sin(8.0 * p.x + 4.0 * sin(6.0 * p.y + iTime) + 3.0 * p.z);
    swirls += cos(6.0 * p.y + 3.0 * sin(8.0 * p.x) + 4.0 * p.z + iTime);
    
    // Add more chaotic patterns
    float chaos = sin(p.x * 10.0 + iTime) * cos(p.z * 8.0 + iTime * 0.5) * 
                 sin(p.y * 12.0 + iTime * 0.7) * 0.1;
    
    float noise = fbm(p * 3.0 + vec3(0.0, 0.0, iTime * 0.2));
    
    return sphere + 0.15 * swirls + 0.1 * noise + chaos;
}

vec2 scene(vec3 p) {
    float planet = candyPlanet(p);
    float ocean = milkOcean(p);
    float candies = floatingCandy(p);
    
    float d = planet;
    float material = 1.0;
    
    if (ocean < d) {
        d = ocean;
        material = 2.0;
    }
    
    if (candies < d) {
        d = candies;
        material = 3.0;
    }
    
    // Add global glitch effect
    vec3 glitch = glitchOffset(p);
    d += length(glitch) * 0.1;
    
    return vec2(d, material);
}

vec3 getNormal(vec3 p) {
    const float h = 0.0001;
    vec2 k = vec2(1.0, -1.0);
    return normalize(
        k.xyy * scene(p + k.xyy * h).x +
        k.yyx * scene(p + k.yyx * h).x +
        k.yxy * scene(p + k.yxy * h).x +
        k.xxx * scene(p + k.xxx * h).x
    );
}

vec2 rayMarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    float material = 0.0;
    
    for(int i = 0; i < 128; i++) {
        vec3 p = ro + t * rd;
        vec2 res = scene(p);
        float d = res.x;
        
        if(d < 0.001 || t > MAX_DIST) {
            material = res.y;
            break;
        }
        t += d * 0.5;
    }
    
    return vec2(t, material);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
    
    // Add screen shake and glitch
    float shake = hash(iTime) * 0.03 * step(0.98, hash(floor(iTime * 4.0)));
    uv += vec2(shake * hash(uv.y), shake * hash(uv.x));
    
    vec3 ro = vec3(0.0, 1.0, -4.0);
    vec3 rd = normalize(vec3(uv, 1.5));
    
    // Camera glitch
    ro += glitchOffset(ro) * 0.5;
    rd += glitchOffset(rd) * 0.02;
    
    float angle = iTime * 0.3;
    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    ro.xz = rot * ro.xz;
    rd.xz = rot * rd.xz;
    
    vec2 result = rayMarch(ro, rd);
    float t = result.x;
    float material = result.y;
    
    vec3 col = vec3(0.0);
    
    if(t < MAX_DIST) {
        vec3 p = ro + t * rd;
        vec3 n = getNormal(p);
        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
        float diff = max(0.0, dot(n, lightDir));
        
        if(material == 1.0) {
            vec3 baseColor = mix(CANDY_PINK, CANDY_BLUE, 
                               fbm(p * 2.0 + vec3(0.0, 0.0, iTime * 0.1)));
            
            float stripes = 0.5 + 0.5 * sin(20.0 * p.x + 10.0 * p.y + 15.0 * p.z);
            baseColor = mix(baseColor, CANDY_WHITE, smoothstep(0.45, 0.55, stripes));
            
            // Add glitch to color
            baseColor *= 1.0 + length(glitchOffset(p));
            
            col = baseColor * (0.2 + 0.8 * diff);
            
            vec3 h = normalize(lightDir - rd);
            float spec = pow(max(0.0, dot(n, h)), 32.0);
            col += CANDY_WHITE * spec;
            
        } else if(material == 2.0) {
            col = MILK_COLOR;
            float fresnel = pow(1.0 - max(0.0, dot(-rd, n)), 3.0);
            col = mix(col, CANDY_WHITE, fresnel * 0.5);
            
            // Add color glitch to milk
            vec3 glitchCol = vec3(hash(p.x + iTime), hash(p.y + iTime), hash(p.z + iTime));
            col = mix(col, glitchCol, 0.1 * step(0.97, hash(floor(iTime * 5.0))));
            
            vec3 h = normalize(lightDir - rd);
            float spec = pow(max(0.0, dot(n, h)), 64.0);
            col += CANDY_WHITE * spec * 0.5;
            
        } else if(material == 3.0) {
            col = mix(CANDY_PURPLE, CANDY_PINK, sin(p.x * 5.0 + iTime) * 0.5 + 0.5);
            col *= diff;
            
            // Add glitch color
            vec3 glitchCol = vec3(hash(p.x * 5.0), hash(p.y * 5.0), hash(p.z * 5.0));
            col = mix(col, glitchCol, 0.2 * step(0.95, hash(floor(iTime * 3.0))));
            
            vec3 h = normalize(lightDir - rd);
            float spec = pow(max(0.0, dot(n, h)), 32.0);
            col += CANDY_WHITE * spec;
        }
        
        float rim = 1.0 - max(0.0, dot(-rd, n));
        rim = pow(rim, 3.0);
        col += CANDY_PURPLE * rim * 0.3;
    }
    
    // Enhanced background with glitch effects
    vec3 bg = vec3(0.0);
    float stars = pow(hash(uv.x * 100.0 + uv.y * 543.0 + iTime), 20.0);
    bg += vec3(stars);
    
    // Add digital noise
    float noise = hash(uv.x * 1000.0 + uv.y * 1000.0 + iTime) * 0.1;
    bg += vec3(noise) * step(0.98, hash(floor(iTime * 10.0)));
    
    col = mix(bg, col, exp(-t * 0.05));
    
    // Add scan lines
    float scanLine = sin(fragCoord.y * 0.5 + iTime * 10.0) * 0.5 + 0.5;
    col *= 0.9 + 0.1 * scanLine;
    
    // Add color aberration
    float aberration = 0.01 * step(0.97, hash(floor(iTime * 4.0)));
    vec3 colShift = col;
    colShift.r = col.r * (1.0 + aberration);
    colShift.b = col.b * (1.0 - aberration);
    col = colShift;
    
    // Add glow with glitch
    float glow = max(0.0, 1.0 - t * 0.25);
    col += CANDY_PINK * pow(glow, 3.0) * 0.3 * (1.0 + hash(iTime) * 0.5);
    
    col = pow(col, vec3(0.4545));
    
    fragColor = vec4(col, 1.0);
}

void main() {
    mainImage(fragColor, gl_FragCoord.xy);
}
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
    }
    return program;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

if (!vertexShader || !fragmentShader) {
    console.error('Shader creation failed');
    throw new Error('Shader creation failed');
}

const program = createProgram(gl, vertexShader, fragmentShader);

if (!program) {
    console.error('Program creation failed');
    throw new Error('Program creation failed');
}

const positionAttributeLocation = gl.getAttribLocation(program, 'aPosition');
const resolutionUniformLocation = gl.getUniformLocation(program, 'iResolution');
const timeUniformLocation = gl.getUniformLocation(program, 'iTime');
const mouseUniformLocation = gl.getUniformLocation(program, 'iMouse');

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

gl.useProgram(program);

gl.enableVertexAttribArray(positionAttributeLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = canvas.height - e.clientY;
});

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function render(time) {
    gl.uniform3f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height, 1.0);
    gl.uniform1f(timeUniformLocation, time * 0.001);
    gl.uniform4f(mouseUniformLocation, mouseX, mouseY, 0.0, 0.0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body></html>