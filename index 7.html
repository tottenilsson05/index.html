
// ASCII characters from darkest to brightest
const ASCII_CHARS = " .:-=+*#%@";

// Initialize canvas
const canvas = document.getElementById('canvas');
let width = Math.floor(window.innerWidth / 8); // Character width
let height = Math.floor(window.innerHeight / 16); // Character height

function resizeCanvas() {
  width = Math.floor(window.innerWidth / 8);
  height = Math.floor(window.innerHeight / 16);
}

// Handle window resize
window.addEventListener('resize', resizeCanvas);

function map(value, fromMin, fromMax, toMin, toMax) {
  return (value - fromMin) * (toMax - toMin) / (fromMax - fromMin) + toMin;
}

function render(time) {
  let output = '';
  const t = time * 0.001;

  for(let y = 0; y < height; y++) {
    for(let x = 0; x < width; x++) {
      // Convert pixel coordinates to UV coordinates
      const u = (x / width) * 2 - 1;
      const v = (y / height) * 2 - 1;
      
      // Simple tunnel effect
      const cx = Math.sin(t) * 0.5;
      const cy = Math.cos(t * 0.5) * 0.3;
      
      // Calculate distance from center point
      const dx = u - cx;
      const dy = v - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      // Add some variation based on position and time
      const angle = Math.atan2(dy, dx);
      const variation = Math.sin(angle * 8 + t * 2) * 0.1;
      
      // Create tunnel effect
      const tunnelEffect = 1 / (dist + variation) * 0.3;
      
      // Map the value to ASCII characters
      const brightness = Math.min(Math.max(tunnelEffect, 0), 1);
      const charIndex = Math.floor(map(brightness, 0, 1, 0, ASCII_CHARS.length - 1));
      output += ASCII_CHARS[charIndex];
    }
    output += '\n';
  }
  
  canvas.textContent = output;
  requestAnimationFrame(render);
}

requestAnimationFrame(render);

</script></body></html>