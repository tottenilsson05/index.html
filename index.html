<title>Vajra Energy Visualization</title>
<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #000;
    font-family: 'Roboto', sans-serif;
    cursor: default;
  }
  body.cursor-locked {
    cursor: none;
  }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    color: #fff;
    font-size: 14px;
    z-index: 100;
  }
  #controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    background-color: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 4px;
    font-size: 0.8em;
    transform: scale(0.8);
    transform-origin: bottom left;
    transition: transform 0.3s ease;
    width: 600px;
    max-width: 100%;
    box-sizing: border-box;
    max-height: 90vh;
    overflow-y: auto;
  }
  #controls.hidden {
    display: none;
  }
  .slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
  }
  .slider-container label {
    width: 200px;
    flex-shrink: 0;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .slider-container input[type="range"] {
    flex: 1;
    margin: 0 5px;
    flex-grow: 1;
  }
  .slider-container span {
    flex: 0 0 40px;
    text-align: right;
  }
  .slider-control-btn {
    background-color: rgba(255,255,255,0.2);
    color: white;
    border: none;
    border-radius: 4px;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
  }
  .slider-container .slider-control-btn {
    width: 20px;
    height: 20px;
    margin: 0 2px;
  }
  .slider-control-btn:hover {
    background-color: rgba(255,255,255,0.4);
  }
  .slider-value {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    color: white;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-shrink: 0;
    min-width: 100px;
    text-align: right;
  }
  #clickInfo {
    position: absolute;
    top: 10px;
    left: 10px;
    color: #fff;
    font-size: 14px;
    z-index: 100;
    background-color: rgba(0,0,0,0.5);
    padding: 4px;
    border-radius: 4px;
    font-size: 0.8em;
    color: rgba(255,255,255,0.5);
    opacity: 1;
  }
  #fullscreenBtn, #infoBtn, #toggleControlsBtn {
    position: absolute;
    padding: 8px;
    background-color: rgba(0,0,0,0.5);
    color: rgba(255,255,255,0.5);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8em;
  }
  #fullscreenBtn {
    top: 10px;
    right: 10px;
  }
  #toggleControlsBtn {
    bottom: 10px;
    right: 10px;
    z-index: 11;
  }
  #autoplayBtn {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px;
    background-color: rgba(0,0,0,0.5);
    color: rgba(255,255,255,0.5);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8em;
    z-index: 11;
  }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    color: rgba(255,255,255,0.5);
    background-color: rgba(0,0,0,0.5);
    padding: 4px;
    border-radius: 4px;
    font-size: 0.8em;
  }
  .info-section {
    background-color: rgba(0,0,0,0.5);
    color: rgba(255,255,255,0.5);
    padding: 8px;
    margin-bottom: 10px;
    border-radius: 4px;
    font-size: 1.39em;
    text-align: center;
  }
  #credits-container {
    width: 100%;
    overflow: hidden;
    position: relative;
    margin-bottom: 10px;
  }
  #credits-marquee {
    display: inline-block;
    white-space: nowrap;
    animation: creditScroll 10s linear infinite;
    color: rgba(255,255,255,0.5);
  }
  #credits-marquee a {
    color: inherit;
    text-decoration: none;
  }
  @keyframes creditScroll {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
<button id="fullscreenBtn">Fullscreen</button>
<button id="toggleControlsBtn">Show Controls</button>
<button id="autoplayBtn">Autoplay</button>
<div id="controls" class="hidden">
  <div class="info-section">
    <p class="info-text">RMB: activate/deactivate Fullscreen Mode<br>V: Start/Stop Recording Energy Viz<br>WASD+Mouse: Movement Controls<br>I: Interaction</p>
  </div>
  <div id="credits-container">
    <div id="credits-marquee">
      <span>Credits to <a href="https://websim.ai/@LightHorus" target="_blank">@LightHorus</a></span>
    </div>
  </div>
  <div class="slider-container">
    <label>Energy Intensity:</label>
    <input type="range" id="energyIntensity" min="0" max="2" step="0.01" value="1">
    <span>1.00</span>
  </div>
  <div class="slider-container">
    <label>Rotation Speed:</label>
    <input type="range" id="rotationSpeed" min="0" max="0.01" step="0.0001" value="0.001">
    <span>0.001</span>
  </div>
  <div class="slider-container">
    <label>Particle Count:</label>
    <input type="range" id="particleCount" min="1000" max="100000" step="1000" value="50000">
    <span>50000</span>
  </div>
  <div class="slider-container">
    <label>Color Shift:</label>
    <input type="range" id="colorShift" min="0" max="1" step="0.01" value="0.5">
    <span>0.50</span>
  </div>
  <div class="slider-container">
    <label>Particle Size:</label>
    <input type="range" id="particleSize" min="0.01" max="0.5" step="0.01" value="0.1">
    <span>0.10</span>
  </div>
  <div class="slider-container">
    <label>Flow Speed:</label>
    <input type="range" id="flowSpeed" min="0.001" max="0.1" step="0.001" value="0.01">
    <span>0.01</span>
  </div>
  <div class="slider-container">
    <label>Noise Scale:</label>
    <input type="range" id="noiseScale" min="0.01" max="0.2" step="0.01" value="0.05">
    <span>0.05</span>
  </div>
  <div class="slider-container">
    <label>Energy Spread:</label>
    <input type="range" id="energySpread" min="5" max="50" step="1" value="20">
    <span>20</span>
  </div>
  <div class="slider-container">
    <label>Color Intensity:</label>
    <input type="range" id="colorIntensity" min="0.1" max="2" step="0.1" value="1">
    <span>1.00</span>
  </div>
  <div class="slider-container">
    <label>Explosion Intensity:</label>
    <input type="range" id="explosionIntensity" min="0" max="2" step="0.01" value="1">
    <span>1.00</span>
  </div>
  <div class="slider-container">
    <label>Explosion Radius:</label>
    <input type="range" id="explosionRadius" min="1" max="20" step="0.1" value="5">
    <span>5.00</span>
  </div>
  <div class="slider-container autoplay-settings" style="opacity: 0.8; background-color: rgba(255, 0, 0, 0.2);">
    <label>Autoplay Period:</label>
    <input type="range" id="autoplayPeriod" min="1" max="300" step="1" value="10">
    <span>10 (300)</span>
  </div>
  <div class="slider-container autoplay-settings" style="opacity: 0.8; background-color: rgba(255, 0, 0, 0.2);">
    <label>Autoplay Period Randomness:</label>
    <input type="range" id="autoplayPeriodRandomness" min="0" max="100" step="1" value="0">
    <span>0 (100)</span>
  </div>
</div>
<div id="clickInfo"></div>

<script>let scene, camera, renderer, particles;
let energyIntensity = 1;
let rotationSpeed = 0.001;
let particleCount = 50000;
let colorShift = 0.5;
let particleSize = 0.1;
let flowSpeed = 0.01;
let noiseScale = 0.05;
let energySpread = 20;
let colorIntensity = 1;
let explosionIntensity = 1;
let explosionRadius = 5;
let time = 0;
let autoplayPeriod = 10;
let autoplayPeriodRandomness = 0;
const simplex = new SimplexNoise();
let autoplayInterval = null;
let autoplayEnabled = true;
let interactionX = 0;
let interactionY = 0;
let isInteracting = false;
let explosionTime = -1;
let mediaRecorder;
let recordedChunks = [];
let isRecording = false;
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let mouseLookEnabled = false;
const moveSpeed = 0.5;
const mouseSensitivity = 0.002;
let pitch = 0;
let yaw = 0;
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 50;
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  createVajraEnergy();
  setupControls();
  setupInteraction();
  window.addEventListener('resize', onWindowResize, false);
  const autoplayBtn = document.getElementById('autoplayBtn');
  autoplayBtn.addEventListener('click', toggleAutoplay);
  autoplayBtn.textContent = 'Stop Autoplay';
  startAutoplay();
  animate();
  const controls = document.getElementById('controls');
  controls.classList.add('hidden');
  const toggleControlsBtn = document.getElementById('toggleControlsBtn');
  toggleControlsBtn.textContent = 'Show Controls';
  document.documentElement.requestFullscreen().catch(err => {
    console.log(`Error attempting to enable fullscreen: ${err.message}`);
  });
  const infoSection = document.querySelector('.info-section .info-text');
  infoSection.innerHTML = infoSection.innerHTML.replace('<br>Click to enable/disable Movement', '');
}
function createVajraEnergy() {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;
    positions[i3] = (Math.random() - 0.5) * energySpread;
    positions[i3 + 1] = (Math.random() - 0.5) * energySpread;
    positions[i3 + 2] = (Math.random() - 0.5) * energySpread;
    colors[i3] = Math.random();
    colors[i3 + 1] = Math.random();
    colors[i3 + 1] = Math.random();
    velocities[i3] = 0;
    velocities[i3 + 1] = 0;
    velocities[i3 + 2] = 0;
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
  const material = new THREE.PointsMaterial({
    size: particleSize,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    transparent: true
  });
  particles = new THREE.Points(geometry, material);
  scene.add(particles);
}
function setupControls() {
  function createSliderControl(sliderId, maxPrecision = 2) {
    const slider = document.getElementById(sliderId);
    const container = slider.closest('.slider-container');
    const minusBtn = document.createElement('button');
    minusBtn.textContent = '-';
    minusBtn.classList.add('slider-control-btn');
    minusBtn.addEventListener('click', () => {
      const step = parseFloat(slider.step);
      const currentVal = parseFloat(slider.value);
      slider.value = Math.max(parseFloat(slider.min), currentVal - step).toFixed(maxPrecision);
      slider.dispatchEvent(new Event('input'));
    });
    const plusBtn = document.createElement('button');
    plusBtn.textContent = '+';
    plusBtn.classList.add('slider-control-btn');
    plusBtn.addEventListener('click', () => {
      const step = parseFloat(slider.step);
      const currentVal = parseFloat(slider.value);
      slider.value = Math.min(parseFloat(slider.max), currentVal + step).toFixed(maxPrecision);
      slider.dispatchEvent(new Event('input'));
    });
    slider.parentNode.insertBefore(minusBtn, slider);
    slider.parentNode.insertBefore(plusBtn, slider.nextSibling);
    const valueSpan = container.querySelector('span');
    valueSpan.classList.add('slider-value');
    function updateValueDisplay() {
      const currentVal = parseFloat(slider.value).toFixed(maxPrecision);
      const maxVal = parseFloat(slider.max).toFixed(maxPrecision);
      valueSpan.textContent = `${currentVal} (${maxVal})`;
      valueSpan.style.minWidth = '120px';
    }
    updateValueDisplay();
    slider.addEventListener('input', updateValueDisplay);
  }
  const sliderIds = ['energyIntensity', 'rotationSpeed', 'particleCount', 'colorShift', 'particleSize', 'flowSpeed', 'noiseScale', 'energySpread', 'colorIntensity', 'explosionIntensity', 'explosionRadius', 'autoplayPeriod', 'autoplayPeriodRandomness'];
  sliderIds.forEach(sliderId => {
    createSliderControl(sliderId, sliderId === 'particleCount' || sliderId === 'autoplayPeriod' || sliderId === 'autoplayPeriodRandomness' ? 0 : 2);
  });
  document.getElementById('energyIntensity').addEventListener('input', e => {
    energyIntensity = parseFloat(e.target.value);
  });
  document.getElementById('rotationSpeed').addEventListener('input', e => {
    rotationSpeed = parseFloat(e.target.value);
  });
  document.getElementById('particleCount').addEventListener('input', e => {
    particleCount = parseInt(e.target.value);
    scene.remove(particles);
    createVajraEnergy();
  });
  document.getElementById('colorShift').addEventListener('input', e => {
    colorShift = parseFloat(e.target.value);
  });
  document.getElementById('particleSize').addEventListener('input', e => {
    particleSize = parseFloat(e.target.value);
    particles.material.size = particleSize;
  });
  document.getElementById('flowSpeed').addEventListener('input', e => {
    flowSpeed = parseFloat(e.target.value);
  });
  document.getElementById('noiseScale').addEventListener('input', e => {
    noiseScale = parseFloat(e.target.value);
  });
  document.getElementById('energySpread').addEventListener('input', e => {
    energySpread = parseFloat(e.target.value);
    scene.remove(particles);
    createVajraEnergy();
  });
  document.getElementById('colorIntensity').addEventListener('input', e => {
    colorIntensity = parseFloat(e.target.value);
  });
  document.getElementById('explosionIntensity').addEventListener('input', e => {
    explosionIntensity = parseFloat(e.target.value);
  });
  document.getElementById('explosionRadius').addEventListener('input', e => {
    explosionRadius = parseFloat(e.target.value);
  });
  document.getElementById('autoplayPeriod').addEventListener('input', e => {
    autoplayPeriod = parseFloat(e.target.value);
    stopAutoplay();
    startAutoplay();
  });
  document.getElementById('autoplayPeriodRandomness').addEventListener('input', e => {
    autoplayPeriodRandomness = parseFloat(e.target.value);
  });
}
function setupInteraction() {
  renderer.domElement.removeEventListener('mousedown', onInteractionStart, false);
  renderer.domElement.removeEventListener('mousemove', onInteractionMove, false);
  renderer.domElement.removeEventListener('mouseup', onInteractionEnd, false);
  renderer.domElement.removeEventListener('touchstart', onInteractionStart, false);
  renderer.domElement.removeEventListener('touchmove', onInteractionMove, false);
  renderer.domElement.removeEventListener('touchend', onInteractionEnd, false);
  document.addEventListener('keydown', handleKeyDown);
  document.addEventListener('keyup', handleKeyUp);
  renderer.domElement.addEventListener('click', enableMouseLook);
  document.addEventListener('mousemove', handleMouseMove);
}
function handleKeyDown(event) {
  switch (event.key.toLowerCase()) {
    case 'w':
      moveForward = true;
      break;
    case 's':
      moveBackward = true;
      break;
    case 'a':
      moveLeft = true;
      break;
    case 'd':
      moveRight = true;
      break;
  }
}
function handleKeyUp(event) {
  switch (event.key.toLowerCase()) {
    case 'w':
      moveForward = false;
      break;
    case 's':
      moveBackward = false;
      break;
    case 'a':
      moveLeft = false;
      break;
    case 'd':
      moveRight = false;
      break;
  }
}
function enableMouseLook(event) {
  if (!mouseLookEnabled) {
    renderer.domElement.requestPointerLock();
  } else {
    document.exitPointerLock();
  }
}
function handleMouseMove(event) {
  if (mouseLookEnabled) {
    yaw -= event.movementX * mouseSensitivity;
    pitch -= event.movementY * mouseSensitivity;
    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
  }
}
document.addEventListener('pointerlockchange', () => {
  mouseLookEnabled = document.pointerLockElement === renderer.domElement;
  document.body.classList.toggle('cursor-locked', mouseLookEnabled);
});
function onInteractionStart(event) {
  event.preventDefault();
  isInteracting = true;
  updateInteractionPosition(event);
  triggerExplosion();
}
function onInteractionMove(event) {
  event.preventDefault();
  if (isInteracting) {
    updateInteractionPosition(event);
  }
}
function onInteractionEnd(event) {
  event.preventDefault();
  isInteracting = false;
}
function updateInteractionPosition(event) {
  if (event.type.startsWith('mouse')) {
    interactionX = event.clientX / window.innerWidth * 2 - 1;
    interactionY = -(event.clientY / window.innerHeight) * 2 + 1;
  } else if (event.type.startsWith('touch')) {
    const touch = event.touches[0];
    interactionX = touch.clientX / window.innerWidth * 2 - 1;
    interactionY = -(touch.clientY / window.innerHeight) * 2 + 1;
  }
  const clickInfo = document.getElementById('clickInfo');
  clickInfo.textContent = `Interaction: (${interactionX.toFixed(2)}, ${interactionY.toFixed(2)})`;
  clickInfo.style.opacity = '1';
}
function triggerExplosion() {
  explosionTime = time;
}
function animate() {
  requestAnimationFrame(animate);
  time += flowSpeed;
  const positions = particles.geometry.attributes.position.array;
  const colors = particles.geometry.attributes.color.array;
  const velocities = particles.geometry.attributes.velocity.array;
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;
    const noise = simplex.noise3D(positions[i3] * noiseScale, positions[i3 + 1] * noiseScale, positions[i3 + 2] * noiseScale + time) * energyIntensity;
    positions[i3] += noise * 0.1 + velocities[i3];
    positions[i3 + 1] += noise * 0.1 + velocities[i3 + 1];
    positions[i3 + 2] += noise * 0.1 + velocities[i3 + 2];
    if (explosionTime >= 0) {
      const dx = interactionX * 50 - positions[i3];
      const dy = interactionY * 50 - positions[i3 + 1];
      const dz = positions[i3 + 2];
      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (distance < explosionRadius) {
        const explosionForce = (1 - distance / explosionRadius) * explosionIntensity;
        velocities[i3] += dx / distance * explosionForce;
        velocities[i3 + 1] += dy / distance * explosionForce;
        velocities[i3 + 2] += dz / distance * explosionForce;
      }
    }
    velocities[i3] *= 0.95;
    velocities[i3 + 1] *= 0.95;
    velocities[i3 + 2] *= 0.95;
    const x = positions[i3];
    const z = positions[i3 + 2];
    positions[i3] = x * Math.cos(rotationSpeed) - z * Math.sin(rotationSpeed);
    positions[i3 + 2] = z * Math.cos(rotationSpeed) + x * Math.sin(rotationSpeed);
    colors[i3] = (Math.sin(time + positions[i3] * 0.1) + 1) * 0.5 * colorShift * colorIntensity;
    colors[i3 + 1] = (Math.sin(time + positions[i3 + 1] * 0.1 + 2) + 1) * 0.5 * (1 - colorShift) * colorIntensity;
    colors[i3 + 2] = (Math.sin(time + positions[i3 + 2] * 0.1 + 4) + 1) * 0.5 * colorIntensity;
    if (isInteracting) {
      const dx = interactionX * 50 - positions[i3];
      const dy = interactionY * 50 - positions[i3 + 1];
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < 10) {
        const force = (1 - distance / 10) * 0.05;
        positions[i3] += dx * force;
        positions[i3 + 1] += dy * force;
        colors[i3] *= 1.5;
        colors[i3 + 1] *= 1.5;
        colors[i3 + 2] *= 1.5;
      }
    }
  }
  particles.geometry.attributes.position.needsUpdate = true;
  particles.geometry.attributes.color.needsUpdate = true;
  particles.geometry.attributes.velocity.needsUpdate = true;
  if (explosionTime >= 0 && time - explosionTime > 1) {
    explosionTime = -1;
  }
  if (moveForward) {
    camera.translateZ(-moveSpeed);
  }
  if (moveBackward) {
    camera.translateZ(moveSpeed);
  }
  if (moveLeft) {
    camera.translateX(-moveSpeed);
  }
  if (moveRight) {
    camera.translateX(moveSpeed);
  }
  camera.rotation.x = pitch;
  camera.rotation.y = yaw;
  const creditsMarquee = document.getElementById('credits-marquee');
  creditsMarquee.style.color = `rgb(
    ${((Math.sin(time + 0) + 1) * 0.5 * 255).toFixed(0)}, 
    ${((Math.sin(time + 2) + 1) * 0.5 * 255).toFixed(0)}, 
    ${((Math.sin(time + 4) + 1) * 0.5 * 255).toFixed(0)}
  )`;
  renderer.render(scene, camera);
}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function toggleAutoplay() {
  if (!autoplayEnabled) {
    startAutoplay();
    autoplayBtn.textContent = 'Stop Autoplay';
  } else {
    stopAutoplay();
    autoplayBtn.textContent = 'Start Autoplay';
  }
  autoplayEnabled = !autoplayEnabled;
}
function startAutoplay() {
  autoplayInterval = setInterval(shuffleConfiguration, getRandomInterval());
}
function stopAutoplay() {
  if (autoplayInterval) {
    clearInterval(autoplayInterval);
    autoplayInterval = null;
  }
}
function getRandomInterval() {
  const baseInterval = autoplayPeriod * 1000;
  const randomnessAmount = autoplayPeriodRandomness / 100;
  const randomVariation = baseInterval * randomnessAmount * (Math.random() * 2 - 1);
  return baseInterval + randomVariation;
}
function shuffleConfiguration() {
  const sliders = ['energyIntensity', 'rotationSpeed', 'particleCount', 'colorShift', 'particleSize', 'flowSpeed', 'noiseScale', 'energySpread', 'colorIntensity', 'explosionIntensity', 'explosionRadius'];
  sliders.forEach(sliderId => {
    const slider = document.getElementById(sliderId);
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const randomValue = Math.random() * (max - min) + min;
    slider.value = randomValue.toFixed(slider.step.includes('.') ? slider.step.split('.')[1].length : 0);
    const event = new Event('input', {
      bubbles: true
    });
    slider.dispatchEvent(event);
  });
  const periodSlider = document.getElementById('autoplayPeriod');
  const currentPeriod = parseFloat(periodSlider.value);
  const randomnessAmount = autoplayPeriodRandomness / 100;
  const randomVariation = currentPeriod * randomnessAmount * (Math.random() * 2 - 1);
  const newPeriodValue = Math.max(parseFloat(periodSlider.min), Math.min(parseFloat(periodSlider.max), currentPeriod + randomVariation));
  periodSlider.value = newPeriodValue.toFixed(0);
  periodSlider.dispatchEvent(new Event('input'));
}
function handleKeyPress(event) {
  if (event.key === 'v' || event.key === 'V') {
    toggleRecording();
  }
  if (event.key === 'i' || event.key === 'I') {
    triggerInteractionAtCenter();
  }
}
function toggleRecording() {
  if (!isRecording) {
    startRecording();
  } else {
    stopRecording();
  }
}
function startRecording() {
  const stream = renderer.domElement.captureStream(30);
  mediaRecorder = new MediaRecorder(stream, {
    mimeType: 'video/webm'
  });
  mediaRecorder.ondataavailable = event => {
    if (event.data.size > 0) {
      recordedChunks.push(event.data);
    }
  };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, {
      type: 'video/webm'
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'vajra_energy_visualization.webm';
    a.click();
    recordedChunks = [];
  };
  mediaRecorder.start();
  isRecording = true;
}
function stopRecording() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
    isRecording = false;
  }
}
function triggerInteractionAtCenter() {
  interactionX = 0;
  interactionY = 0;
  isInteracting = true;
  triggerExplosion();
  const clickInfo = document.getElementById('clickInfo');
  clickInfo.textContent = `Interaction: (0.00, 0.00)`;
  clickInfo.style.opacity = '1';
  setTimeout(() => {
    isInteracting = false;
    clickInfo.style.opacity = '0';
  }, 1000);
}
const fullscreenBtn = document.getElementById('fullscreenBtn');
const toggleControlsBtn = document.getElementById('toggleControlsBtn');
const controls = document.getElementById('controls');
const autoplayBtn = document.getElementById('autoplayBtn');
fullscreenBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
});
document.addEventListener('fullscreenchange', () => {
  if (document.fullscreenElement) {
    fullscreenBtn.textContent = 'Exit Fullscreen';
    fullscreenBtn.style.display = 'none';
    toggleControlsBtn.style.display = 'none';
    controls.style.display = 'none';
    autoplayBtn.style.display = 'none';
    document.getElementById('clickInfo').style.display = 'none';
  } else {
    fullscreenBtn.textContent = 'Fullscreen';
    fullscreenBtn.style.display = '';
    toggleControlsBtn.style.display = '';
    controls.style.display = '';
    autoplayBtn.style.display = '';
    document.getElementById('clickInfo').style.display = '';
  }
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
toggleControlsBtn.addEventListener('click', () => {
  if (controls.classList.contains('hidden')) {
    controls.classList.remove('hidden');
    toggleControlsBtn.textContent = 'Hide Controls';
  } else {
    controls.classList.add('hidden');
    toggleControlsBtn.textContent = 'Show Controls';
  }
});
autoplayBtn.addEventListener('click', toggleAutoplay);
document.addEventListener('contextmenu', event => {
  event.preventDefault();
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
});
document.addEventListener('keydown', handleKeyPress);
init();</script>
</body></html>
