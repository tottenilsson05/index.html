<html>
<head>
  <title>RetroComp: Advanced Keyboard Interrupt Masking Logic</title>
  <style>
    body {
      font-family: 'VT323', monospace;
      background-color: #000;
      color: #0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      margin: 0;
    }
    h1, h2 {
      text-align: center;
      text-shadow: 2px 2px #030;
    }
    #keyboard {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 5px;
      margin-bottom: 20px;
    }
    .key {
      width: 50px;
      height: 50px;
      background-color: #001100;
      border: 2px solid #0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.1s;
      user-select: none;
    }
    .key:hover {
      background-color: #002200;
    }
    .key:active, .key.pressed {
      background-color: #0f0;
      color: #000;
    }
    #info, #mask-info {
      background-color: #001100;
      border: 2px solid #0f0;
      padding: 20px;
      margin-top: 20px;
      max-width: 600px;
      text-align: justify;
    }
    #interrupt-display, #mask-display, #ghost-display {
      background-color: #001100;
      border: 2px solid #0f0;
      padding: 10px;
      margin-top: 20px;
      width: 580px;
      min-height: 50px;
      font-size: 24px;
      text-align: center;
    }
    #oscilloscope {
      width: 600px;
      height: 200px;
      background: radial-gradient(circle at center, #001800 0%, #000800 70%, #000300 100%);
      border: 2px solid #0f0;
      margin-top: 20px;
    }
    .scanline {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(to bottom, 
          rgba(0,255,0,0) 0%,
          rgba(0,255,0,0.3) 50%,
          rgba(0,255,0,0) 100%);
      opacity: 0.7;
      animation: scanline 10s linear infinite;
      pointer-events: none;
    }
    @keyframes scanline {
      0% { transform: translateY(0); }
      100% { transform: translateY(100vh); }
    }
    #mask-controls {
      display: flex;
      justify-content: space-around;
      width: 100%;
      margin-top: 20px;
    }
    .mask-button {
      background-color: #001100;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .mask-button:hover {
      background-color: #002200;
    }
    .mask-button:active {
      background-color: #0f0;
      color: #000;
    }
    #3d-keyboard {
      width: 600px;
      height: 400px;
      background: #001100;
      border: 2px solid #0f0;
      margin: 20px auto;
    }

    #circuit-diagram {
      width: 600px; 
      height: 300px;
      background: #001100;
      border: 2px solid #0f0;
      margin: 20px auto;
    }

    #data-flow {
      width: 600px;
      height: 200px;
      background: #001100; 
      border: 2px solid #0f0;
      margin: 20px auto;
    }

    @keyframes pulse {
      0% { stroke-dashoffset: 0; }
      100% { stroke-dashoffset: 100; }
    }

    .circuit-path {
      stroke-dasharray: 10;
      animation: pulse 1s linear infinite;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=VT323&amp;display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
</head>
<body>
  <div class="scanline"></div>
  <h1>RetroComp: Advanced Keyboard Interrupt Masking Logic</h1>
  <div id="keyboard"></div>
  <h2>Interrupt Display</h2>
  <div id="interrupt-display">No key pressed</div>
  <h2>Mask Display</h2>
  <div id="mask-display">Mask: 0xFF (All interrupts enabled)</div>
  <h2>Ghost Key Detection</h2>
  <div id="ghost-display">No ghost keys detected</div>
  <div id="mask-controls">
    <button class="mask-button" id="mask-all">Mask All</button>
    <button class="mask-button" id="unmask-all">Unmask All</button>
    <button class="mask-button" id="toggle-mask">Toggle Mask</button>
  </div>
  <h2>Interrupt Signal</h2>
  <canvas id="oscilloscope"></canvas>
  <div id="3d-keyboard"></div>
  <div id="circuit-diagram"></div>
  <div id="data-flow"></div>
  <div id="info">
    <p>This advanced simulation demonstrates keyboard interrupt masking logic with ghost key detection. In addition to masking interrupts, the system now prevents false positives caused by multiple simultaneous key presses.</p>
    <p>The masking logic allows the system to ignore certain key presses based on the current mask value, while the ghost key detection prevents erroneous interrupts from phantom key presses.</p>
    <p>Try pressing multiple keys simultaneously to see how the system handles potential ghost keys.</p>
  </div>
  <div id="mask-info">
    <p>Advanced Masking Logic:</p>
    <ol>
      <li>Each key is assigned a bit in the 8-bit mask.</li>
      <li>If the corresponding bit in the mask is 1, the key&apos;s interrupt is enabled.</li>
      <li>If the corresponding bit in the mask is 0, the key&apos;s interrupt is disabled.</li>
      <li>The system performs a bitwise AND operation between the key&apos;s bit and the mask.</li>
      <li>If the result is non-zero, an interrupt is generated.</li>
      <li>Ghost key detection is applied to prevent false positives from multiple key presses.</li>
    </ol>
  </div>

  <script>const keyboard = document.getElementById('keyboard');
const interruptDisplay = document.getElementById('interrupt-display');
const maskDisplay = document.getElementById('mask-display');
const ghostDisplay = document.getElementById('ghost-display');
const oscilloscope = document.getElementById('oscilloscope');
const ctx = oscilloscope.getContext('2d');
const keys = 'QWERTYUIOPASDFGHJKL'.split('');
let pressedKeys = new Set();
let signalData = new Array(600).fill(0);
let interruptMask = 0xFF;
let scene, camera, renderer;
let keyboard3D;
let circuitPaths = [];
let dataFlowParticles = [];
oscilloscope.width = 600;
oscilloscope.height = 200;
keys.forEach((key, index) => {
  const keyElement = document.createElement('div');
  keyElement.className = 'key';
  keyElement.textContent = key;
  keyElement.addEventListener('mousedown', () => handleKeyPress(key, index));
  keyElement.addEventListener('mouseup', () => handleKeyRelease(key));
  keyElement.addEventListener('mouseout', () => handleKeyRelease(key));
  keyboard.appendChild(keyElement);
});
function handleKeyPress(key, index) {
  const keyElement = Array.from(keyboard.children).find(el => el.textContent === key);
  keyElement.classList.add('pressed');
  pressedKeys.add(key);
  const ghostKeys = detectGhostKeys();
  if (ghostKeys.length > 0) {
    ghostDisplay.textContent = `Ghost keys detected: ${ghostKeys.join(', ')}`;
    addSignalDataPoint(0);
  } else {
    ghostDisplay.textContent = 'No ghost keys detected';
    if (interruptMask & 1 << index) {
      interruptDisplay.textContent = `Interrupt generated for key: ${key}`;
      addSignalDataPoint(1);
    } else {
      interruptDisplay.textContent = `Interrupt masked for key: ${key}`;
      addSignalDataPoint(0);
    }
  }
  dataFlowParticles.push({
    x: 0,
    y: 100,
    vx: 5
  });
  gsap.to(keyboard3D.position, {
    y: -0.5,
    duration: 0.1,
    yoyo: true,
    repeat: 1
  });
  circuitPaths[index % 3].style.strokeWidth = "4";
  setTimeout(() => {
    circuitPaths[index % 3].style.strokeWidth = "2";
  }, 100);
}
function handleKeyRelease(key) {
  const keyElement = Array.from(keyboard.children).find(el => el.textContent === key);
  keyElement.classList.remove('pressed');
  pressedKeys.delete(key);
  if (pressedKeys.size === 0) {
    interruptDisplay.textContent = 'No key pressed';
    ghostDisplay.textContent = 'No ghost keys detected';
  } else {
    const ghostKeys = detectGhostKeys();
    if (ghostKeys.length > 0) {
      ghostDisplay.textContent = `Ghost keys detected: ${ghostKeys.join(', ')}`;
    } else {
      ghostDisplay.textContent = 'No ghost keys detected';
    }
  }
  addSignalDataPoint(0);
}
function detectGhostKeys() {
  const pressedPositions = Array.from(pressedKeys).map(key => keys.indexOf(key));
  const ghostKeys = [];
  for (let i = 0; i < pressedPositions.length; i++) {
    for (let j = i + 1; j < pressedPositions.length; j++) {
      const row1 = Math.floor(pressedPositions[i] / 10);
      const col1 = pressedPositions[i] % 10;
      const row2 = Math.floor(pressedPositions[j] / 10);
      const col2 = pressedPositions[j] % 10;
      if (row1 !== row2 && col1 !== col2) {
        const potentialGhost1 = keys[row1 * 10 + col2];
        const potentialGhost2 = keys[row2 * 10 + col1];
        if (pressedKeys.has(potentialGhost1) && !ghostKeys.includes(potentialGhost1)) {
          ghostKeys.push(potentialGhost1);
        }
        if (pressedKeys.has(potentialGhost2) && !ghostKeys.includes(potentialGhost2)) {
          ghostKeys.push(potentialGhost2);
        }
      }
    }
  }
  return ghostKeys;
}
function addSignalDataPoint(value) {
  signalData.push(value);
  signalData.shift();
  drawOscilloscope();
}
function drawOscilloscope() {
  ctx.fillStyle = '#001100';
  ctx.fillRect(0, 0, oscilloscope.width, oscilloscope.height);
  ctx.strokeStyle = '#030';
  ctx.lineWidth = 1;
  for (let i = 0; i < oscilloscope.width; i += 50) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, oscilloscope.height);
    ctx.stroke();
  }
  for (let i = 0; i < oscilloscope.height; i += 50) {
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(oscilloscope.width, i);
    ctx.stroke();
  }
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#0f0';
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const step = oscilloscope.width / signalData.length;
  for (let i = 0; i < signalData.length; i++) {
    const x = i * step;
    const y = oscilloscope.height - signalData[i] * oscilloscope.height / 2 - oscilloscope.height / 4;
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  ctx.shadowBlur = 0;
}
function maskAll() {
  interruptMask = 0x00;
  updateMaskDisplay();
}
function unmaskAll() {
  interruptMask = 0xFF;
  updateMaskDisplay();
}
function toggleMask() {
  interruptMask = ~interruptMask & 0xFF;
  updateMaskDisplay();
}
function updateMaskDisplay() {
  maskDisplay.textContent = `Mask: 0x${interruptMask.toString(16).toUpperCase().padStart(2, '0')} (${interruptMask.toString(2).padStart(8, '0')})`;
}
document.getElementById('mask-all').addEventListener('click', maskAll);
document.getElementById('unmask-all').addEventListener('click', unmaskAll);
document.getElementById('toggle-mask').addEventListener('click', toggleMask);
document.addEventListener('keydown', event => {
  const key = event.key.toUpperCase();
  const index = keys.indexOf(key);
  if (index !== -1 && !pressedKeys.has(key)) {
    handleKeyPress(key, index);
  }
});
document.addEventListener('keyup', event => {
  const key = event.key.toUpperCase();
  if (keys.includes(key)) {
    handleKeyRelease(key);
  }
});
function init3DScene() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(600, 400);
  document.getElementById('3d-keyboard').appendChild(renderer.domElement);
  const geometry = new THREE.BoxGeometry(10, 1, 5);
  const material = new THREE.MeshPhongMaterial({
    color: 0x00ff00,
    emissive: 0x002200,
    wireframe: true
  });
  keyboard3D = new THREE.Mesh(geometry, material);
  scene.add(keyboard3D);
  camera.position.z = 15;
  const light = new THREE.DirectionalLight(0x00ff00, 1);
  light.position.set(0, 10, 10);
  scene.add(light);
  animate3D();
}
function animate3D() {
  requestAnimationFrame(animate3D);
  keyboard3D.rotation.x += 0.01;
  keyboard3D.rotation.y += 0.01;
  renderer.render(scene, camera);
}
function initCircuitDiagram() {
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("viewBox", "0 0 600 300");
  document.getElementById('circuit-diagram').appendChild(svg);
  const paths = ["M 50,50 L 550,50", "M 50,150 L 550,150", "M 50,250 L 550,250"];
  paths.forEach(path => {
    const element = document.createElementNS("http://www.w3.org/2000/svg", "path");
    element.setAttribute("d", path);
    element.setAttribute("stroke", "#0f0");
    element.setAttribute("stroke-width", "2");
    element.setAttribute("fill", "none");
    element.classList.add("circuit-path");
    svg.appendChild(element);
    circuitPaths.push(element);
  });
}
function initDataFlow() {
  const canvas = document.createElement('canvas');
  canvas.width = 600;
  canvas.height = 200;
  document.getElementById('data-flow').appendChild(canvas);
  const ctx = canvas.getContext('2d');
  function animateDataFlow() {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0, 0, 600, 200);
    dataFlowParticles.forEach((particle, i) => {
      ctx.fillStyle = '#0f0';
      ctx.fillRect(particle.x, particle.y, 2, 2);
      particle.x += particle.vx;
      particle.y += Math.sin(particle.x / 50) * 2;
      if (particle.x > 600) {
        dataFlowParticles.splice(i, 1);
      }
    });
    requestAnimationFrame(animateDataFlow);
  }
  animateDataFlow();
}
setInterval(() => {
  const ghostKeys = detectGhostKeys();
  addSignalDataPoint(pressedKeys.size > 0 && ghostKeys.length === 0 ? 1 : 0);
}, 16);
window.addEventListener('load', () => {
  init3DScene();
  initCircuitDiagram();
  initDataFlow();
});</script>
</body>
</html>
