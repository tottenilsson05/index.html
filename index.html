<title>NeoCosmos - Quantum Disruption Arsenal</title>
<style>
body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
#game-container { width: 100%; height: 100%; }
#hud { position: absolute; bottom: 20px; left: 20px; color: #0ff; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 5px #0ff; }
#crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); }
#crosshair::before, #crosshair::after { content: ''; position: absolute; background: #0ff; box-shadow: 0 0 5px #0ff; }
#crosshair::before { width: 2px; height: 20px; left: 9px; }
#crosshair::after { width: 20px; height: 2px; top: 9px; }
#logo { position: absolute; top: 10px; right: 10px; font-family: 'Orbitron', sans-serif; color: #0ff; font-size: 24px; text-shadow: 0 0 10px #0ff; }
#weapon { position: absolute; top: 20px; left: 20px; width: 200px; height: 100px; }
</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
<div id="game-container"></div>
<div id="hud">Sync: 100%</div>
<div id="crosshair"></div>
<div id="logo">NeoCosmos</div>
<canvas id="weapon"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Initialize the scene, camera, and renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('game-container').appendChild(renderer.domElement);

// Audio context setup
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

// Function to create and play a sound
function playSound(frequency, duration, type = 'sine') {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    
    gainNode.gain.setValueAtTime(1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
}

// Create a neon cube
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

// Add a glowing grid floor
const floorGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = Math.PI / 2;
floor.position.y = -1;
scene.add(floor);

// Create 3D gun model
const gunGroup = new THREE.Group();

// Gun body
const gunBodyGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.6);
const gunBodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
const gunBody = new THREE.Mesh(gunBodyGeometry, gunBodyMaterial);
gunGroup.add(gunBody);

// Gun barrel
const gunBarrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
const gunBarrelMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
const gunBarrel = new THREE.Mesh(gunBarrelGeometry, gunBarrelMaterial);
gunBarrel.rotation.x = Math.PI / 2;
gunBarrel.position.set(0, 0, 0.35);
gunGroup.add(gunBarrel);

// Gun handle
const gunHandleGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.15);
const gunHandleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
const gunHandle = new THREE.Mesh(gunHandleGeometry, gunHandleMaterial);
gunHandle.position.set(0, -0.15, 0.1);
gunGroup.add(gunHandle);

// Energy cells
for (let i = 0; i < 3; i++) {
    const cellGeometry = new THREE.SphereGeometry(0.03, 8, 8);
    const cellMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
    cell.position.set(-0.05 + i * 0.05, 0.05, -0.1);
    gunGroup.add(cell);
}

// Gun tip for projectile emission
const gunTip = new THREE.Object3D();
gunTip.position.set(0, 0, 0.7);
gunGroup.add(gunTip);

// Position the gun
gunGroup.position.set(0.3, -0.2, -0.5);
camera.add(gunGroup);
scene.add(camera);

// Position the camera
camera.position.z = 5;

// Handle window resizing
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Improved movement controls
const moveSpeed = 0.1;
const jumpForce = 0.2;
const gravity = 0.01;
let verticalVelocity = 0;
const keys = {};
document.addEventListener('keydown', (e) => keys[e.code] = true);
document.addEventListener('keyup', (e) => keys[e.code] = false);

function moveCamera() {
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

    if (keys['KeyW']) camera.position.addScaledVector(forward, moveSpeed);
    if (keys['KeyS']) camera.position.addScaledVector(forward, -moveSpeed);
    if (keys['KeyA']) camera.position.addScaledVector(right, -moveSpeed);
    if (keys['KeyD']) camera.position.addScaledVector(right, moveSpeed);

    // Apply gravity
    verticalVelocity -= gravity;
    camera.position.y += verticalVelocity;

    // Check for ground collision
    if (camera.position.y <= 0) {
        camera.position.y = 0;
        verticalVelocity = 0;
    }

    // Jump
    if (keys['Space'] && camera.position.y === 0) {
        verticalVelocity = jumpForce;
        playSound(220, 0.1, 'square'); // Jump sound
    }
}

// Improved mouse look controls
let isLocked = false;
const pitchObject = new THREE.Object3D();
camera.add(pitchObject);

document.addEventListener('mousemove', (e) => {
    if (isLocked) {
        const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
        const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;

        camera.rotation.y -= movementX * 0.002;
        pitchObject.rotation.x -= movementY * 0.002;
        pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
    }
});

let isMouseDown = false;
let chargeTime = 0;
const maxChargeTime = 1000; // 1 second for full charge

renderer.domElement.addEventListener('mousedown', () => {
    if (isLocked) {
        isMouseDown = true;
        chargeTime = 0;
    } else {
        renderer.domElement.requestPointerLock();
    }
});

renderer.domElement.addEventListener('mouseup', () => {
    if (isLocked) {
        isMouseDown = false;
        fireWeapon(chargeTime);
        chargeTime = 0;
    }
});

document.addEventListener('pointerlockchange', () => {
    isLocked = document.pointerLockElement === renderer.domElement;
});

// Weapon functionality
function fireWeapon(charge) {
    const gunTipWorldPosition = new THREE.Vector3();
    gunTip.getWorldPosition(gunTipWorldPosition);
    
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(camera.quaternion);
    
    if (charge >= maxChargeTime / 2) {
        // Fire a beam for larger charges
        const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, 100, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.7 });
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        
        beam.position.copy(gunTipWorldPosition);
        beam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
        
        scene.add(beam);
        
        // Play beam sound
        playSound(440, 0.5, 'sawtooth');
        
        // Fade out and remove the beam
        const fadeOutTime = 500; // 0.5 seconds
        const startTime = Date.now();
        
        function fadeOutBeam() {
            const elapsedTime = Date.now() - startTime;
            if (elapsedTime < fadeOutTime) {
                beam.material.opacity = 0.7 * (1 - elapsedTime / fadeOutTime);
                requestAnimationFrame(fadeOutBeam);
            } else {
                scene.remove(beam);
            }
        }
        
        fadeOutBeam();
    } else {
        // Fire a small projectile for smaller charges
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        
        bullet.position.copy(gunTipWorldPosition);
        bullet.velocity = direction.multiplyScalar(0.5);
        
        scene.add(bullet);
        
        // Play projectile sound
        playSound(880, 0.1, 'sine');
        
        // Remove bullet after 2 seconds
        setTimeout(() => {
            scene.remove(bullet);
        }, 2000);
    }
}

// Draw weapon UI on canvas
const weaponCanvas = document.getElementById('weapon');
const ctx = weaponCanvas.getContext('2d');

function drawWeaponUI() {
    ctx.clearRect(0, 0, weaponCanvas.width, weaponCanvas.height);
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2;
    
    // Draw gun body
    ctx.beginPath();
    ctx.moveTo(50, 80);
    ctx.lineTo(150, 80);
    ctx.lineTo(150, 60);
    ctx.lineTo(130, 40);
    ctx.lineTo(50, 40);
    ctx.closePath();
    ctx.stroke();
    
    // Draw gun barrel
    ctx.beginPath();
    ctx.moveTo(150, 70);
    ctx.lineTo(190, 70);
    ctx.lineTo(190, 50);
    ctx.lineTo(150, 50);
    ctx.stroke();
    
    // Draw energy cells
    for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(70 + i * 30, 60, 8, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0, 255, 255, ${0.5 + i * 0.2})`;
        ctx.fill();
        ctx.stroke();
    }
    
    // Draw charge indicator
    if (isMouseDown) {
        const chargeWidth = (chargeTime / maxChargeTime) * 140;
        ctx.fillStyle = chargeTime >= maxChargeTime / 2 ? '#00f' : '#0ff';
        ctx.fillRect(50, 85, chargeWidth, 5);
    }
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    moveCamera();
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
    
    if (isMouseDown) {
        chargeTime = Math.min(chargeTime + 16, maxChargeTime); // Increase charge time (assuming 60fps)
        // Visualize charge on the gun model
        const chargeScale = 1 + (chargeTime / maxChargeTime) * 0.2;
        gunGroup.scale.set(chargeScale, chargeScale, chargeScale);
    } else {
        gunGroup.scale.set(1, 1, 1);
    }
    
    // Update and remove bullets
    scene.children.forEach((child) => {
        if (child.velocity) {
            child.position.add(child.velocity);
        }
    });
    
    renderer.render(scene, camera);
    drawWeaponUI();
}
animate();
</script>
</body></html>
