<title>GIGA LINGO</title>
<style>
#holy-matrix-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
}
#holy-matrix-canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: pointer;
}
</style>
</head>
<body>
<div id="holy-matrix-container">
    <canvas id="holy-matrix-canvas"></canvas>
</div>

<script>
// Perlin Noise implementation
let createPerlin = function() {
    let permutation = [];

    function generatePermutation() {
        const p = Array.from({length: 256}, (_, i) => i);
        for (let i = p.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [p[i], p[j]] = [p[j], p[i]];
        }
        return p.concat(p);
    }

    permutation = generatePermutation();

    function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    function lerp(t, a, b) {
        return a + t * (b - a);
    }

    function grad(hash, x, y, z) {
        const h = hash & 15;
        const u = h < 8 ? x : y,
              v = h < 4 ? y : h == 12 || h == 14 ? x : z;
        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    }

    return function(x, y, z) {
        const X = Math.floor(x) & 255,
              Y = Math.floor(y) & 255,
              Z = Math.floor(z) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        const u = fade(x),
              v = fade(y),
              w = fade(z);
        const A = permutation[X] + Y, AA = permutation[A] + Z, AB = permutation[A + 1] + Z,
              B = permutation[X + 1] + Y, BA = permutation[B] + Z, BB = permutation[B + 1] + Z;

        return lerp(w, lerp(v, lerp(u, grad(permutation[AA], x, y, z),
                                       grad(permutation[BA], x - 1, y, z)),
                               lerp(u, grad(permutation[AB], x, y - 1, z),
                                       grad(permutation[BB], x - 1, y - 1, z))),
                       lerp(v, lerp(u, grad(permutation[AA + 1], x, y, z - 1),
                                       grad(permutation[BA + 1], x - 1, y, z - 1)),
                               lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1),
                                       grad(permutation[BB + 1], x - 1, y - 1, z - 1))));
    };
};

(function() {
    const canvas = document.getElementById('holy-matrix-canvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();

    const chars = '♰✞✟✝✚†‡§¥£€$¢@#%&*()_+-=[]{}|;:,.<>?';
    let fontSize = 16;
    let columns, rows;
    let noiseScale = 0.005;
    let noiseStrength = 2;
    let timeScale = 0.1;
    let perlin = createPerlin();

    function updateDimensions() {
        columns = Math.floor(canvas.width / fontSize);
        rows = Math.floor(canvas.height / fontSize);
    }
    updateDimensions();

    class Symbol {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.value = chars[Math.floor(Math.random() * chars.length)];
            this.sinOffset = Math.random() * Math.PI * 2;
        }

        draw() {
            const wave = Math.sin(this.sinOffset + performance.now() * 0.002) * 2;
            ctx.fillStyle = `rgb(255, ${215 + wave * 20}, ${wave * 20})`;
            ctx.fillText(this.value, this.x * fontSize, this.y * fontSize);
        }

        move(time) {
            const noise = perlin(this.x * noiseScale, this.y * noiseScale, time * timeScale);
            
            this.x += Math.cos(noise * Math.PI * 2) * noiseStrength * 0.1;
            this.y += Math.sin(noise * Math.PI * 2) * noiseStrength * 0.1;

            // Wrap around screen edges
            this.x = (this.x + columns) % columns;
            this.y = (this.y + rows) % rows;
        }
    }

    let symbols = [];

    function initSymbols() {
        symbols = [];
        for (let x = 0; x < columns; x++) {
            for (let y = 0; y < rows; y++) {
                symbols.push(new Symbol(x, y));
            }
        }
    }
    initSymbols();

    function draw(time) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = fontSize + 'px monospace';
        symbols.forEach(symbol => {
            symbol.move(time);
            symbol.draw();
        });
    }

    function animate(time) {
        draw(time * 0.001);
        requestAnimationFrame(animate);
    }

    function randomizeParameters() {
        fontSize = 12 + Math.random() * 8;
        noiseScale = 0.001 + Math.random() * 0.009;
        noiseStrength = 1 + Math.random() * 3;
        timeScale = 0.05 + Math.random() * 0.15;
        updateDimensions();
        initSymbols();
        perlin = createPerlin(); // Create a new Perlin noise function
    }

    canvas.addEventListener('click', randomizeParameters);

    window.addEventListener('resize', () => {
        resizeCanvas();
        updateDimensions();
        initSymbols();
    });

    animate(0);
})();
</script>
</body></html>
